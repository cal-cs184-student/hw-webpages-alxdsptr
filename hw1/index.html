<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 1 Write-Up</h1>
		<div style="text-align: center;">Names: Ruoyu Lin</div>

		<br>

		Link to webpage: <a href="https://cal-cs184-student.github.io/hw-webpages-alxdsptr/">cs184.eecs.berkeley.edu/sp25</a>
		
		<br>

		Link to GitHub repository: <a href="https://github.com/cal-cs184-student/hw-webpages-alxdsptr">cs184.eecs.berkeley.edu/sp25</a>

		<!--
		We've already added one heading per task, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		Give a high-level overview of what you implemented in this homework. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the homework.

		<h2>Task 1: Drawing Single-Color Triangles</h2>
		Naive method: First computing the bounding box of the triangle by computing the minimum and maximum x and y values of the three points. Then make sure the triangle is counterclockwise. Mark the first point as A, the second point as B and the third point as C. Compute the cross product of AB and BC, if it's negative, then the triangle is clockwise and we need to swap B and C to make it counterclockwise. After that we iterate through each pixel in the bounding box and check if the pixel is inside the triangle by doing 3 line tests (using the method in the lecture slides). 

		<figure>
			<img src="test4-1.png" width="400px"/></p>
			<figcaption>the rendered basic/test4.svg</figcaption>
		</figure>
		

		<p>Extra credit: Use the scanline method to render the triangle. First, sort the three vertices by their y values. Then iterate from y0 to y1, and inside the loop iterate x from the left edge of the triangle to the right edge. Then iterate from y1 to y2 and do the same thing. The x values of edge is computed by adding the slope, avoiding multiplication operations to improve efficiency. Also, use tricks like calculating loop conditions beforehand to avoid calling the floor() function inside the loop to reduce overhead. Below is the timing comparison table in milliseconds.</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse; border: 1px solid black;">
				<tr>
					<td style="text-align: center; border: 1px solid black;">naive</td>
					<td style="text-align: center; border: 1px solid black;">scan</td>
				</tr>
				<tr>
					<td style="text-align: center; border: 1px solid black;">1.1222</td>
					<td style="text-align: center; border: 1px solid black;">0.4692</td>
				</tr>
			</table>
		</div>

		<!-- <p>Here is an example 2x2 gridlike structure using an HTML table. Each <b>tr</b> is a row and each <b>td</b> is a column in that row. You might find this useful for framing and showing your result images in an organized fashion.</p>
		 -->
		
		<h2>Task 2: Antialiasing by Supersampling</h2>
		I changed the size of the sample buffer to weight * height * supersampling_rate, and store the subpixel colors of a given pixel in consecutive locations in the sample buffer array. Inside the  resolve_to_framebuffer function, when computing the color of a pixel, I average the colors of the corresponding subpixels in the sample buffer, and store the result to the framebuffer. When rasterizing a triangle, I divide the pixel into a grid of subpixels according to the supersampling rate, and check if each subpixel is inside the triangle to determine the color of the subpixel, then store the color of the subpixel in the sample buffer.
		Supersampling is useful because it acts as an approximate one pixel filter, which reduces signal frequencies above the Nyquist frequency, therefore reduces aliasing artifacts. 

		<p>Below are the rendered results and pixel inspector results under different supersampling rates for basic/test4.svg. </p>	
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="1.png" width="400px"/>
				  <figcaption>sample rate 1x</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="4.png" width="400px"/>
				  <figcaption>sample rate 4x</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="16.png" width="400px"/>
				  <figcaption>sample rate 16x</figcaption>
				</td>
			  </tr>
			  <tr></tr>
				<td style="text-align: center;">
				  <img src="1p.png" width="400px"/>
				  <figcaption>sample rate 1x</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="4p.png" width="400px"/>
				  <figcaption>sample rate 4x</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="16p.png" width="400px"/>
				  <figcaption>sample rate 16x</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		<p>Explanation for the pixel inspector results: When supersampling rate is 1, if the center of the pixel is not inside the triangle, the whole pixel is white. So when the triangle is very thin, there will be discontinuity in the middle.
			<br>
		After increasing the supersampling rate, even if the center of the pixel is not inside the triangle, some subpixels can still be inside the triangle, so the pixel will be colored according to the ratio of subpixels inside the triangle, which makes the edges smoother. 
		</p>

		<h2>Task 3: Transforms</h2>
		I'm trying to make the robot stretch its body by raising its arms and widening its leg stance.
		<figure>
			<img src="my_robot.png" width="400px"/></p>
			<figcaption>the rendered my_robots.svg</figcaption>
		</figure>

		<h2>Task 4: Barycentric coordinates</h2>
		The barycentric coordinates describe how close a point is to each of the 3 vertices, in other words, the extent to which a point is influenced by the three vertices of the triangle. Intuitively, this can be computed by computing the area of the triangle formed by the point and each edge of the triangle, and dividing it by the area of the original triangle. As shown in the svg below, how close point P is to vertex A can be computed by S1/S_total (S_total = S1 + S2 + S3), because the closer P is to A, the larger S1 becomes, and the more P is influenced by A — so its color will also be closer to A's color. The same logic applies to the other vertices.
		<img src="triangle.svg" width="400px"/></p>

		<!-- <p>The rendered test7.svg:  -->
			<figure>
				<img src="color.png" width="400px"/></p>
				<figcaption>the rendered test7.svg</figcaption>
		</figure>

		<h2>Task 5: "Pixel sampling" for texture mapping</h2>
		Pixel sampling is to sample the color of a pixel from a texture image using texture coordinates. In my implementation, I first compute the texture coordinates for each pixel by interpolating the texture coordinates of the triangle vertices using barycentric coordinates. Then I use the texture coordinates to sample the color from the texture image and assign it to the pixel in the samplebuffer. The nearest sampling is simply taking the color of the nearest texel to the given texture coordinate. The bilinear sampling is using linear interpolation to compute the weighted average of the four nearest texels as the final color of the pixel.</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="1n.png" width="400px"/>
				  <figcaption>nearest, 1x</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="1b.png" width="400px"/>
				  <figcaption>bilinear, 1x</figcaption>
				</td>
				
			  </tr>
			  <tr></tr>
				<td style="text-align: center;">
				  <img src="16n.png" width="400px"/>
				  <figcaption>nearest, 16x</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="16b.png" width="400px"/>
				  <figcaption>bilinear, 16x</figcaption>
				</td>
				
			  </tr>
			</table>
		</div>
		<p>The white line is discontinuous when using nearest sampling at 1x supersample rate. And then using bilinear sampling under same supersample rate, the line became a little more smoother. And under 16x supersample rate, the line became really smooth both for nearest sampling and sampling.
		<br>Generally speaking, when the resolution of the texture image is lower than the rendering resolution, bilinear sampling will be significantly better than nearest sampling. This is because, when using nearest sampling, two adjacent pixels may sample the same texel in the texture image, leading to artifacts like jaggies. In contrast, if bilinear sampling is used,  o adjacent pixels would not be exactly the same since it performs a weighted average of the four neighboring texels, therefore the result will looks smoother.
		</p>
		<h2>Task 6: "Level Sampling" with mipmaps for texture mapping</h2>

		The idea of level sampling is that when the resolution of the texture is much higher than the rendering resolution, a pixel's footprint may cover multiple texels. To solve this, we precompute different levels of downsampled texture images, and when sampling the color of a pixel, we choose the closest texture level based on the side length of the pixel footprint.<br>
		To implement this, I first compute the uv coordinate of (x+1, y) and (x, y+1), then subtract the uv coordinate of (x, y) to get \(\frac{d[u\ v]}{dx}\) and \(\frac{d[u\ v]}{dy}\), then I scale the u by the texture width and v by the texture height so that they represent real number of texels. Then I compute the \( L_2 \) norm for each of these vectors, and take the maximum as the final sampling level. </p>
		<p>
			tradeoffs: 
			<!-- pixel sampling: Using bilinear pixel sampling doesn't need additional memory. It increases
			  -->
			<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center; border: 1px solid black;">
					method
				</td>
				<td style="text-align: center; border: 1px solid black;">
				  speed
				</td>
				<td style="text-align: center; border: 1px solid black;">
					memory usage
				</td>
				<td style="text-align: center; border: 1px solid black;">
					antialiasing power
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center; border: 1px solid black;">
				  pixel sampling
				</td>
				<td style="text-align: center; border: 1px solid black;">
					fast, only need to read 4 texels and do 3 lerps 
				</td>
				<td style="text-align: center; border: 1px solid black;">
					no additional memory needed
				</td>
				<td style="text-align: center; border: 1px solid black;">
					can only solve the magnification problem
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center; border: 1px solid black;">
				  level sampling
				</td>
				<td style="text-align: center; border: 1px solid black;">
					need to compute 2 more uv coordinates and do some extra calculations to determine the sampling level, but still pretty fast
				</td>
				<td style="text-align: center; border: 1px solid black;">
					need 33% moree memory to store the mipmaps
				</td>
				<td style="text-align: center; border: 1px solid black;">
					can solve the minification problem
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center; border: 1px solid black;">
					supersampling
				</td>
				<td style="text-align: center; border: 1px solid black;">
					slow, need supersampling rate times more computations
				</td>
				<td style="text-align: center; border: 1px solid black;">
					need supersampling rate times more memory to store the sample buffer	
				</td>
				<td style="text-align: center; border: 1px solid black;">
					can solve both magnification and minification problem
				</td>
			</tr>
			</table>
		</div>
		</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="zn.png" width="400px"/>
				  <figcaption>L_ZERO, P_NEAREST</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="zb.png" width="400px"/>
				  <figcaption>L_ZERO, P_BILINEAR</figcaption>
				</td>
				
			  </tr>
			  <tr></tr>
				<td style="text-align: center;">
				  <img src="nn.png" width="400px"/>
				  <figcaption>L_NEAREST, P_NEAREST</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="nb.png" width="400px"/>
				  <figcaption>L_NEAREST, P_BILINEAR</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		From the rendering results above we can see that when the texture resolution is really high, there will be Moiré patterns when using L_ZERO, and using bilinear pixel sampling can't really solve the problem. But when using MIPMAPs, the Moiré patterns are significantly reduced, and using bilinear pixel sampling can further improve the visual quality by making the line smoother.
		</div>
	</body>
</html>